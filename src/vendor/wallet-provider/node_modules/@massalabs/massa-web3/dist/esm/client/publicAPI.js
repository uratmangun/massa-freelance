/* eslint-disable @typescript-eslint/naming-convention */
import { Mas } from '../basicElements';
import { formatReadOnlyCallResponse, formatReadOnlyExecuteSCResponse, formatReadOnlyExecuteSCParams, } from '.';
import { formatDatastoreKey } from '../utils/formatter';
import { MAX_GAS_CALL } from '../smartContracts';
import { OperationStatus } from '../operation';
import isEqual from 'lodash.isequal';
import { Connector } from './connector';
import { getPublicApiByChainId } from '../utils/networks';
export class PublicAPI {
    url;
    options;
    connector;
    lastStatus;
    // eslint-disable-next-line max-params
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.connector = new Connector(url, this.options);
    }
    static async fromProvider(provider) {
        const networkInfo = await provider.networkInfos();
        const url = networkInfo.url
            ? networkInfo.url
            : getPublicApiByChainId(networkInfo.chainId);
        if (!url) {
            throw new Error('Provider does not have a node URL');
        }
        return new PublicAPI(url);
    }
    async executeReadOnlyBytecode(params) {
        return this.connector
            .execute_read_only_bytecode([formatReadOnlyExecuteSCParams(params)])
            .then((r) => formatReadOnlyExecuteSCResponse(r[0]));
    }
    async executeMultipleReadOnlyBytecode(executeReadonlyParams) {
        const params = executeReadonlyParams.map((param) => formatReadOnlyExecuteSCParams(param));
        const res = await this.connector.execute_read_only_bytecode(params);
        return res.map((r) => formatReadOnlyExecuteSCResponse(r));
    }
    async executeReadOnlyCall(params) {
        const [res] = await this.connector.execute_read_only_call([
            {
                max_gas: Number(params.maxGas ?? MAX_GAS_CALL),
                target_address: params.target,
                target_function: params.func,
                parameter: Array.from(params.parameter),
                caller_address: params.caller,
                coins: params.coins ? Mas.toString(params.coins) : null,
                fee: params.fee ? Mas.toString(params.fee) : null,
            },
        ]);
        if (!res) {
            throw new Error('No result returned from execute_read_only_call');
        }
        return formatReadOnlyCallResponse(res);
    }
    async executeMultipleReadOnlyCall(readOnlyCalls) {
        const params = readOnlyCalls.map((call) => ({
            max_gas: Number(call.maxGas ?? MAX_GAS_CALL),
            target_address: call.target,
            target_function: call.func,
            parameter: Array.from(call.parameter),
            caller_address: call.caller,
            coins: call.coins ? Mas.toString(call.coins) : null,
            fee: call.fee ? Mas.toString(call.fee) : null,
        }));
        const res = await this.connector.execute_read_only_call(params);
        return res.map((r) => formatReadOnlyCallResponse(r));
    }
    async getAddressInfo(address) {
        return this.getMultipleAddressInfo([address]).then((r) => r[0]);
    }
    async getBalance(address, final = true) {
        return this.getAddressInfo(address).then((r) => {
            return Mas.fromString(final ? r.final_balance : r.candidate_balance);
        });
    }
    async getMultipleAddressInfo(addresses) {
        return this.connector.get_addresses(addresses);
    }
    async getAddressesBytecode(addressFilter) {
        return this.connector
            .get_addresses_bytecode([addressFilter])
            .then((r) => Uint8Array.from(r[0]));
    }
    async executeMultipleGetAddressesBytecode(addressFilters) {
        const bytecodes = await this.connector.get_addresses_bytecode(addressFilters);
        return bytecodes.map((bytecode) => Uint8Array.from(bytecode));
    }
    async getBlock(blockId) {
        return this.connector.get_blocks([blockId]).then((r) => r[0]);
    }
    async getMultipleBlocks(blockIds) {
        return this.connector.get_blocks(blockIds);
    }
    async getBlockcliqueBlock(slot) {
        return this.connector.get_blockclique_block_by_slot(slot);
    }
    async getCliques() {
        return this.connector.get_cliques();
    }
    async getAddressesDatastoreKeys(params) {
        const parsedParams = params.map((param) => {
            const prefix = param.prefix
                ? Array.from(formatDatastoreKey(param.prefix))
                : [];
            const start_key = param.startKey
                ? Array.from(formatDatastoreKey(param.startKey))
                : null;
            const end_key = param.endKey
                ? Array.from(formatDatastoreKey(param.endKey))
                : null;
            return {
                address: param.address,
                is_final: param.final ?? true,
                prefix,
                start_key,
                // default value is true
                inclusive_start_key: param.inclusiveStartKey ?? null,
                end_key,
                // default value is true
                inclusive_end_key: param.inclusiveEndKey ?? null,
                // default value is 500
                count: param.maxCount ?? null,
            };
        });
        const data = await this.connector.get_addresses_keys(parsedParams);
        return data.map((r) => ({
            address: r.address,
            isFinal: r.is_final,
            keys: r.keys.map((key) => Uint8Array.from(key)),
        }));
    }
    async getDataStoreKeys(contract, filter = new Uint8Array(), final = true) {
        const addrInfo = await this.getAddressInfo(contract);
        const keys = final
            ? addrInfo.final_datastore_keys
            : addrInfo.candidate_datastore_keys;
        return keys
            .filter((key) => !filter.length ||
            isEqual(Uint8Array.from(key.slice(0, filter.length)), filter))
            .map((key) => Uint8Array.from(key));
    }
    async getDatastoreEntries(inputs, final = true) {
        const entriesQuery = inputs.map((entry) => {
            const byteKey = formatDatastoreKey(entry.key);
            return {
                key: Array.from(byteKey),
                address: entry.address,
            };
        });
        const res = await this.connector.get_datastore_entries(entriesQuery);
        return res.map((r) => {
            const val = final ? r.final_value : r.candidate_value;
            return val ? Uint8Array.from(val) : null;
        });
    }
    async getDatastoreEntry(key, address, final = true) {
        return this.getDatastoreEntries([{ key, address }], final).then((r) => r[0]);
    }
    async getSlotTransfers(slot) {
        return this.connector.get_slots_transfers([slot]).then((r) => r[0]);
    }
    async getMultipleSlotTransfers(slots) {
        return this.connector.get_slots_transfers(slots);
    }
    async getEndorsement(endorsementId) {
        return this.getMultipleEndorsements([endorsementId]).then((r) => r[0]);
    }
    async getMultipleEndorsements(endorsementIds) {
        return this.connector.get_endorsements(endorsementIds);
    }
    async getEvents(filter) {
        const formattedFilter = {
            start: filter.start,
            end: filter.end,
            emitter_address: filter.smartContractAddress,
            original_caller_address: filter.callerAddress,
            original_operation_id: filter.operationId,
            is_final: filter.isFinal,
            is_error: filter.isError,
        };
        return this.connector.get_filtered_sc_output_event(formattedFilter);
    }
    async getGraphInterval(start, end) {
        return this.connector.get_graph_interval({ start, end });
    }
    async getOperations(operationIds) {
        return this.connector.get_operations(operationIds);
    }
    async getOperation(operationId) {
        return this.getOperations([operationId]).then((r) => r[0]);
    }
    async getOperationStatus(operationId) {
        const op = await this.getOperation(operationId);
        if (!op) {
            return OperationStatus.NotFound;
        }
        if (op.op_exec_status === null) {
            if (op.is_operation_final === null) {
                return OperationStatus.NotFound;
            }
            throw new Error('unexpected status');
        }
        if (op.in_pool) {
            return OperationStatus.PendingInclusion;
        }
        if (!op.is_operation_final) {
            return op.op_exec_status
                ? OperationStatus.SpeculativeSuccess
                : OperationStatus.SpeculativeError;
        }
        return op.op_exec_status ? OperationStatus.Success : OperationStatus.Error;
    }
    // todo rename PageRequest pagination
    async getStakers(pagination) {
        return this.connector.get_stakers(pagination);
    }
    async status() {
        this.lastStatus = await this.connector.get_status();
        return this.lastStatus;
    }
    async getMinimalFee() {
        if (!this.lastStatus) {
            await this.status();
        }
        if (!this.lastStatus.minimal_fees) {
            throw new Error('minimal fees: not available');
        }
        return Mas.fromString(this.lastStatus.minimal_fees);
    }
    async getChainId() {
        if (!this.lastStatus) {
            await this.status();
        }
        return BigInt(this.lastStatus.chain_id);
    }
    async fetchPeriod() {
        const status = await this.status();
        if (!status.last_slot) {
            throw new Error('last slot: not available');
        }
        return status.last_slot.period;
    }
    async getCurrentSlot() {
        const { last_slot } = await this.status();
        return last_slot;
    }
    static convertOperationInput(data) {
        return {
            serialized_content: Array.from(data.data),
            creator_public_key: data.publicKey,
            signature: data.signature,
        };
    }
    async sendOperation(data) {
        return this.sendOperations([data]).then((r) => r[0]);
    }
    async sendOperations(data) {
        return this.sendMultipleOperations(data.map((e) => PublicAPI.convertOperationInput(e)));
    }
    async sendMultipleOperations(data) {
        return this.connector.send_operations(data);
    }
    async deferredCallQuote(quoteRequests) {
        return this.connector.get_deferred_call_quote(quoteRequests);
    }
    async deferredCallsInfo(deferredCallsIds) {
        return this.connector.get_deferred_call_info(deferredCallsIds);
    }
    async deferredCallsBySlot(slots) {
        return this.connector.get_deferred_call_ids_by_slot(slots);
    }
}
