import { Mas } from '../basicElements';
import { SendOperationInput, EventFilter as EvtFilter, ReadOnlyCallResult, ClientOptions, DatastoreEntry, ExecuteSCReadOnlyParams, ExecuteSCReadOnlyResult, AddressDatastoreKeys, DatastoreKeysRequest } from '.';
import { OperationStatus, ReadOnlyParams } from '../operation';
import { Connector } from './connector';
import { rpcTypes as t } from 'src/generated/';
import { Provider, PublicProvider } from '../provider';
export declare class PublicAPI {
    url: string;
    options: Partial<ClientOptions>;
    connector: Connector;
    lastStatus: t.NodeStatus;
    constructor(url: string, options?: Partial<ClientOptions>);
    static fromProvider(provider: Provider | PublicProvider): Promise<PublicAPI>;
    executeReadOnlyBytecode(params: ExecuteSCReadOnlyParams): Promise<ExecuteSCReadOnlyResult>;
    executeMultipleReadOnlyBytecode(executeReadonlyParams: ExecuteSCReadOnlyParams[]): Promise<ExecuteSCReadOnlyResult[]>;
    executeReadOnlyCall(params: ReadOnlyParams): Promise<ReadOnlyCallResult>;
    executeMultipleReadOnlyCall(readOnlyCalls: ReadOnlyParams[]): Promise<ReadOnlyCallResult[]>;
    getAddressInfo(address: string): Promise<t.AddressInfo>;
    getBalance(address: string, final?: boolean): Promise<Mas.Mas>;
    getMultipleAddressInfo(addresses: string[]): Promise<t.AddressInfo[]>;
    getAddressesBytecode(addressFilter: t.AddressFilter): Promise<Uint8Array>;
    executeMultipleGetAddressesBytecode(addressFilters: t.AddressFilter[]): Promise<Uint8Array[]>;
    getBlock(blockId: t.BlockId): Promise<t.BlockInfo>;
    getMultipleBlocks(blockIds: t.BlockId[]): Promise<t.BlockInfo[]>;
    getBlockcliqueBlock(slot: t.Slot): Promise<t.Block>;
    getCliques(): Promise<t.Clique[]>;
    getAddressesDatastoreKeys(params: DatastoreKeysRequest[]): Promise<AddressDatastoreKeys[]>;
    getDataStoreKeys(contract: string, filter?: Uint8Array, final?: boolean): Promise<Uint8Array[]>;
    getDatastoreEntries(inputs: DatastoreEntry[], final?: boolean): Promise<(Uint8Array | null)[]>;
    getDatastoreEntry(key: string | Uint8Array, address: string, final?: boolean): Promise<Uint8Array | null>;
    getSlotTransfers(slot: t.Slot): Promise<t.TransferReceipt[]>;
    getMultipleSlotTransfers(slots: t.Slot[]): Promise<t.TransferReceipt[][]>;
    getEndorsement(endorsementId: string): Promise<t.EndorsementInfo>;
    getMultipleEndorsements(endorsementIds: string[]): Promise<t.EndorsementInfo[]>;
    getEvents(filter: EvtFilter): Promise<t.SCOutputEvent[]>;
    getGraphInterval(start?: number, end?: number): Promise<t.GraphInterval[]>;
    getOperations(operationIds: string[]): Promise<t.OperationInfo[]>;
    getOperation(operationId: string): Promise<t.OperationInfo | undefined>;
    getOperationStatus(operationId: string): Promise<OperationStatus>;
    getStakers(pagination: t.Pagination): Promise<t.Staker[]>;
    status(): Promise<t.NodeStatus>;
    getMinimalFee(): Promise<bigint>;
    getChainId(): Promise<bigint>;
    fetchPeriod(): Promise<number>;
    getCurrentSlot(): Promise<t.Slot>;
    private static convertOperationInput;
    sendOperation(data: SendOperationInput): Promise<t.OperationId>;
    sendOperations(data: SendOperationInput[]): Promise<t.OperationId[]>;
    sendMultipleOperations(data: t.OperationInput[]): Promise<t.OperationId[]>;
    deferredCallQuote(quoteRequests: t.DeferredCallsQuoteRequest[]): Promise<t.DeferredCallsQuoteResponse[]>;
    deferredCallsInfo(deferredCallsIds: string[]): Promise<t.DeferredCallResponse[]>;
    deferredCallsBySlot(slots: t.Slot[]): Promise<t.DeferredCallsSlotResponse[]>;
}
