import { EventFilter, ExecuteSCReadOnlyParams, ExecuteSCReadOnlyResult } from '../../client';
import { Network } from '../../utils';
import { NodeStatusInfo, PublicProvider, ReadSCData, ReadSCParams, SlotExecutionOutputFilter } from '..';
import { OperationStatus } from '../../operation';
import { OutputEvents } from '../../generated/client-types';
import { Slot as tSlot } from '../../generated/client-types';
import { ABICallStack, ExecutionQueryRequestItem, NewBlocksServerResponse, NewEndorsementsServerResponse, NewFilledBlocksServerResponse, NewOperationsServerResponse, NewSlotExecutionOutputsServerResponse, QueryStateResponse, SlotABICallStacks, TransferInfos } from '../../generated/grpc/public_pb';
import { OperationInfo, OperationWrapper, OpType } from '../../generated/grpc/massa/model/v1/operation_pb';
import { SlotRange } from '../../generated/grpc/massa/model/v1/slot_pb';
import { EndorsementInfo, EndorsementWrapper } from '../../generated/grpc/massa/model/v1/endorsement_pb';
import { BlockInfo, BlockParent, BlockWrapper } from '../../generated/grpc/massa/model/v1/block_pb';
import { SlotDraw } from '../../generated/grpc/massa/model/v1/draw_pb';
import { StakerEntry } from '../../generated/grpc/massa/model/v1/staker_pb';
import { PublicServiceClient } from '../../generated/grpc/PublicServiceClientPb';
import { ClientReadableStream } from 'grpc-web';
export declare class GrpcPublicProvider implements PublicProvider {
    client: PublicServiceClient;
    url: string;
    constructor(client: PublicServiceClient, url: string);
    static fromGrpcUrl(url: string): GrpcPublicProvider;
    /**
     * Streams new slot execution outputs
     * @param filters - The filters to apply to the stream
     * @returns A stream of new slot execution outputs
     */
    newSlotExecutionOutputsStream(filters: SlotExecutionOutputFilter): ClientReadableStream<NewSlotExecutionOutputsServerResponse>;
    /**
     * Streams new filled blocks
     * @param addresses - Optional list of addresses to filter by
     * @param blockIds - Optional list of block IDs to filter by
     * @param slotRange - Optional slot range to filter by
     * @returns A stream of new filled blocks
     */
    newFilledBlocksStream(addresses?: string[], blockIds?: string[], slotRange?: SlotRange): ClientReadableStream<NewFilledBlocksServerResponse>;
    /**
     * Streams new endorsements
     * @param addresses - Optional list of addresses to filter by
     * @param endorsementIds - Optional list of endorsement IDs to filter by
     * @param blockIds - Optional list of block IDs to filter by
     * @returns A stream of new endorsements
     */
    newEndorsementsStream(addresses?: string[], endorsementIds?: string[], blockIds?: string[]): ClientReadableStream<NewEndorsementsServerResponse>;
    /**
     * Streams new blocks
     * @param blockIds - Optional list of block IDs to filter by
     * @param addresses - Optional list of addresses to filter by
     * @param slotRange - Optional slot range to filter by
     * @returns A stream of new blocks
     */
    newBlockStream(addresses?: string[], blockIds?: string[], slotRange?: SlotRange): ClientReadableStream<NewBlocksServerResponse>;
    /**
     * Streams new operations
     * @param addresses - Optional list of addresses to filter by
     * @param operationIds - Optional list of operation IDs to filter by
     * @param types - Optional list of operation types to filter by
     * @returns A stream of new operations
     */
    newOperationsStream(addresses?: string[], operationIds?: string[], types?: OpType[]): ClientReadableStream<NewOperationsServerResponse>;
    /**
     * Executes a state query on the blockchain
     */
    queryState(queries: ExecutionQueryRequestItem[]): Promise<QueryStateResponse>;
    balanceOf(addresses: string[], final?: boolean): Promise<{
        address: string;
        balance: bigint;
    }[]>;
    /**
     * Searches for operations based on IDs or addresses
     */
    searchOperations(operationIds?: string[], addresses?: string[]): Promise<OperationInfo[]>;
    /**
     * Retrieves ABI call stacks for specified operations
     */
    getOperationABICallStacks(operationIds: string[]): Promise<ABICallStack[]>;
    /**
     * Retrieves ABI call stacks for specified slots
     */
    getSlotABICallStacks(slots: tSlot[]): Promise<SlotABICallStacks[]>;
    /**
     * Retrieves transfer information for specified slots
     */
    getSlotTransfers(slots: tSlot[]): Promise<TransferInfos[]>;
    /**
     * Searches for endorsements based on various criteria
     */
    searchEndorsements(endorsementIds?: string[], addresses?: string[], blockIds?: string[]): Promise<EndorsementInfo[]>;
    /**
     * Retrieves storage keys for a smart contract with optional filtering and pagination
     */
    getStorageKeys(address: string, filter?: Uint8Array | string, final?: boolean): Promise<Uint8Array[]>;
    /**
     * Reads storage values for specified keys in a smart contract
     */
    readStorage(address: string, keys: Uint8Array[] | string[], final?: boolean): Promise<(Uint8Array | null)[]>;
    /**
     * Retrieves the current transaction throughput of the network
     */
    getTransactionsThroughput(): Promise<number>;
    /**
     * Retrieves selector draws for specified addresses and slot range
     */
    getSelectorDraws(addresses?: string[], slotRange?: SlotRange): Promise<SlotDraw[]>;
    /**
     * Retrieves detailed information about specified operations
     */
    getOperations(operationIds: string[]): Promise<OperationWrapper[]>;
    /**
     * Retrieves the best parent blocks for the next block
     */
    getNextBlockBestParent(): Promise<BlockParent[]>;
    /**
     * Retrieves detailed information about specified endorsements
     */
    getEndorsements(endorsementIds: string[]): Promise<EndorsementWrapper[]>;
    /**
     * Retrieves detailed information about specified blocks
     */
    getBlocks(blockIds: string[]): Promise<BlockWrapper[]>;
    /**
     * Searches for blocks based on various criteria
     */
    searchBlocks(blockIds?: string[], addresses?: string[], slotRange?: SlotRange): Promise<BlockInfo[]>;
    /**
     * Retrieves events based on specified filters
     */
    getEvents(filter: EventFilter): Promise<OutputEvents>;
    networkInfos(): Promise<Network>;
    getOperationStatus(opId: string): Promise<OperationStatus>;
    /**
     * Retrieves a list of stakers with optional filtering by rolls
     */
    getStakers(minRolls?: number, maxRolls?: number, limit?: number): Promise<StakerEntry[]>;
    getNodeStatus(): Promise<NodeStatusInfo>;
    readSC(params: ReadSCParams): Promise<ReadSCData>;
    executeSCReadOnly(params: ExecuteSCReadOnlyParams): Promise<ExecuteSCReadOnlyResult>;
}
