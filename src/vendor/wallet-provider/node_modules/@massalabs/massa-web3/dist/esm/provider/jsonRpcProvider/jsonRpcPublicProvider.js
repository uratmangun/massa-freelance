import { GAS_ESTIMATION_TOLERANCE, } from '..';
import { CHAIN_ID, DEFAULT_GET_DATASTORE_KEYS_PAGE_SIZE, Mas, MAX_GAS_CALL, MAX_GAS_EXECUTE, minBigInt, NetworkName, parseCallArgs, PublicAPI, PublicApiUrl, } from '../..';
import { formatNodeStatusObject } from '../../client/formatObjects';
// Randomly chosen address that exists on buildnet & mainnet.
// this is used as a workaround for https://github.com/massalabs/massa/issues/4912
const PLACEHOLDER_CALLER = 'AU12hCMYq5LoYktCeEYetJWow9Ttr2N4Pcbek7uS9e5u2Er5X4tAn';
export class JsonRpcPublicProvider {
    client;
    constructor(client) {
        this.client = client;
    }
    static fromRPCUrl(url) {
        return new JsonRpcPublicProvider(new PublicAPI(url));
    }
    static mainnet() {
        return JsonRpcPublicProvider.fromRPCUrl(PublicApiUrl.Mainnet);
    }
    static buildnet() {
        return JsonRpcPublicProvider.fromRPCUrl(PublicApiUrl.Buildnet);
    }
    async balanceOf(addresses, final = true) {
        const addressesInfo = await this.client.getMultipleAddressInfo(addresses);
        const balances = addressesInfo.map((addressInfo) => ({
            address: addressInfo.address,
            balance: final
                ? Mas.fromString(addressInfo.final_balance)
                : Mas.fromString(addressInfo.candidate_balance),
        }));
        return balances;
    }
    async networkInfos() {
        const chainId = await this.client.getChainId();
        let name = 'Unknown';
        if (chainId === CHAIN_ID.Mainnet) {
            name = NetworkName.Mainnet;
        }
        else if (chainId === CHAIN_ID.Buildnet) {
            name = NetworkName.Buildnet;
        }
        return {
            name,
            chainId,
            url: this.client.url,
            minimalFee: await this.client.getMinimalFee(),
        };
    }
    async getOperationStatus(opId) {
        return this.client.getOperationStatus(opId);
    }
    async getEvents(filter) {
        return this.client.getEvents(filter);
    }
    async getNodeStatus() {
        const status = await this.client.status();
        return formatNodeStatusObject(status);
    }
    /**
     * Reads smart contract function.
     * @param params - readSCParams.
     * @returns A promise that resolves to a ReadSCData.
     *
     * @remarks Be a aware that if you don't provide a caller address, it will generate a random one.
     */
    async readSC(params) {
        const parameter = parseCallArgs(params.parameter);
        const caller = params.caller ?? PLACEHOLDER_CALLER;
        const readOnlyParams = {
            ...params,
            caller,
            parameter,
        };
        return this.client.executeReadOnlyCall(readOnlyParams);
    }
    async getStorageKeys(address, filter = new Uint8Array(), final = true) {
        return this.getAllDatastoreKeys(address, filter, final);
    }
    /**
     * Wrapper for getAddressesDatastoreKeys that handles pagination to fetch all datastore keys.
     * @param address - The address to get datastore keys for
     * @param filter - Optional prefix filter for keys
     * @param final - Whether to get final or candidate keys
     * @returns Promise resolving to all datastore keys for the address
     */
    async getAllDatastoreKeys(address, filter = new Uint8Array(), final = true) {
        const allKeys = [];
        let startKey = undefined;
        let hasMoreKeys = true;
        while (hasMoreKeys) {
            const request = {
                address,
                final,
                prefix: filter.length > 0 ? filter : undefined,
                startKey,
                inclusiveStartKey: startKey ? false : true, // Exclude the start key if it's from previous batch
                maxCount: DEFAULT_GET_DATASTORE_KEYS_PAGE_SIZE,
            };
            const response = await this.client.getAddressesDatastoreKeys([request]);
            const addressKeys = response[0];
            if (!addressKeys || addressKeys.keys.length === 0) {
                hasMoreKeys = false;
                break;
            }
            allKeys.push(...addressKeys.keys);
            // If we got less than the max count, we've reached the end
            if (addressKeys.keys.length < DEFAULT_GET_DATASTORE_KEYS_PAGE_SIZE) {
                hasMoreKeys = false;
            }
            else {
                // Use the last key as start for next iteration
                startKey = addressKeys.keys[addressKeys.keys.length - 1];
            }
        }
        return allKeys;
    }
    async readStorage(address, keys, final = true) {
        const entries = keys.map((key) => ({ address, key }));
        return this.client.getDatastoreEntries(entries, final);
    }
    /**
     * Returns the gas estimation for a given function.
     *
     * @remarks To avoid running out of gas, the gas estimation is increased by 20%.
     *
     * @param params - ReadSCParams. caller must be provided
     * @throws If the read operation returns an error.
     * @returns The gas estimation for the operation execution.
     */
    async getGasEstimation(params) {
        if (!params.caller) {
            throw new Error('Caller must be provided for gas estimation');
        }
        const result = await this.readSC(params);
        if (result.info.error) {
            throw new Error(result.info.error);
        }
        // TODO: add coins estimation by analysing the stateChanges
        const gasCost = BigInt(result.info.gasCost);
        return minBigInt(
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        gasCost + (gasCost * GAS_ESTIMATION_TOLERANCE) / 100n, MAX_GAS_CALL);
    }
    async executeSCReadOnly(params) {
        const caller = params.caller ?? PLACEHOLDER_CALLER;
        const result = await this.client.executeReadOnlyBytecode({
            ...params,
            caller,
        });
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    async executeSCGasEstimation(params) {
        const result = await this.client.executeReadOnlyBytecode({
            ...params,
            maxGas: MAX_GAS_EXECUTE,
        });
        if (result.error) {
            throw new Error(result.error);
        }
        // TODO: add coins estimation by analysing the stateChanges
        const gasCost = BigInt(result.gasCost);
        return minBigInt(
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        gasCost + (gasCost * GAS_ESTIMATION_TOLERANCE) / 100n, MAX_GAS_EXECUTE);
    }
}
