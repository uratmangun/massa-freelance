import { Args, bytesToStr, MRC20BalanceCreationCost, U256, U8, } from '../basicElements';
import { SmartContract } from '../smartContracts';
import { ErrorDataEntryNotFound } from '../errors/dataEntryNotFound';
/**
 * @class MRC20
 *
 *
 * Class representing an MRC20 token smart contract.
 * Extends the SmartContract class to provide methods for interacting with an MRC20 token.
 * MRC20 contract is available here: https://github.com/massalabs/massa-standards/blob/main/smart-contracts/assembly/contracts/FT/token.ts
 *
 *  @example
 * ```typescript
 * const token = new MRC20(provider, <tokenAddr>);
 * const balance = await token.balanceOf(<accountAddr>);
 * console.log(`Your balance: ${balance}`);
 *
 * const transferOperation = await token.transfer(<recipientAddr>, BigInt(10000));
 * console.log(`Transfer operation id: ${transferOperation.id}`);
 * ```
 */
export class MRC20 extends SmartContract {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _version;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _name;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _symbol;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _decimals;
    async version(options) {
        if (this._version) {
            return this._version;
        }
        const res = await this.read('version', undefined, options);
        return (this._version = bytesToStr(res.value));
    }
    async name() {
        if (this._name) {
            return this._name;
        }
        const res = await this.provider.readStorage(this.address, ['NAME'], true);
        if (!res[0]) {
            throw new ErrorDataEntryNotFound({ key: 'NAME', address: this.address });
        }
        return (this._name = bytesToStr(res[0]));
    }
    async symbol() {
        if (this._symbol) {
            return this._symbol;
        }
        const res = await this.provider.readStorage(this.address, ['SYMBOL'], true);
        if (!res[0]) {
            throw new ErrorDataEntryNotFound({ key: 'SYMBOL', address: this.address });
        }
        return (this._symbol = bytesToStr(res[0]));
    }
    async decimals() {
        if (this._decimals) {
            return this._decimals;
        }
        const res = await this.provider.readStorage(this.address, ['DECIMALS'], true);
        if (!res[0]) {
            throw new ErrorDataEntryNotFound({
                key: 'DECIMALS',
                address: this.address,
            });
        }
        return (this._decimals = Number(U8.fromBytes(res[0])));
    }
    async totalSupply(final = true) {
        const res = await this.provider.readStorage(this.address, ['TOTAL_SUPPLY'], final);
        if (!res[0]) {
            throw new ErrorDataEntryNotFound({
                key: 'TOTAL_SUPPLY',
                address: this.address,
            });
        }
        return U256.fromBytes(res[0]);
    }
    async balanceOf(address, options) {
        const res = await this.read('balanceOf', new Args().addString(address), options);
        return U256.fromBytes(res.value);
    }
    async balancesOf(addresses, final = true) {
        const res = await this.provider.readStorage(this.address, addresses.map((a) => `BALANCE${a}`), final);
        return res.map((v, i) => ({
            address: addresses[i],
            balance: v ? U256.fromBytes(v) : 0n,
        }));
    }
    async transfer(to, amount, options) {
        let opts = options;
        if (!options?.coins) {
            const coins = await MRC20BalanceCreationCost(this.provider, this.address, to);
            opts = {
                ...options,
                coins,
            };
        }
        return this.call('transfer', new Args().addString(to).addU256(amount), opts);
    }
    async allowance(ownerAddress, spenderAddress, options) {
        const res = await this.read('allowance', new Args().addString(ownerAddress).addString(spenderAddress), options);
        return U256.fromBytes(res.value);
    }
    async increaseAllowance(spenderAddress, amount, options) {
        return this.call('increaseAllowance', new Args().addString(spenderAddress).addU256(amount), options);
    }
    async decreaseAllowance(spenderAddress, amount, options) {
        return this.call('decreaseAllowance', new Args().addString(spenderAddress).addU256(amount), options);
    }
    async transferFrom(spenderAddress, recipientAddress, amount, options) {
        let opts = options;
        if (!options?.coins) {
            const coins = await MRC20BalanceCreationCost(this.provider, this.address, recipientAddress);
            opts = {
                ...options,
                coins,
            };
        }
        return this.call('transferFrom', new Args()
            .addString(spenderAddress)
            .addString(recipientAddress)
            .addU256(amount), opts);
    }
}
