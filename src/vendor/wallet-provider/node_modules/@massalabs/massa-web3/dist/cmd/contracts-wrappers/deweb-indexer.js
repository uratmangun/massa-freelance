"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DewebIndexer = exports.DEWEB_INDEXER_CONTRACTS = void 0;
const utils_1 = require("../utils");
const provider_1 = require("../provider");
const smartContracts_1 = require("../smartContracts");
const utils_2 = require("./utils");
const basicElements_1 = require("../basicElements");
const indexer_keys_1 = require("../deweb/keys/indexer_keys");
const deweb_site_keys_1 = require("../deweb/keys/deweb_site_keys");
const publicAPI_1 = require("../client/publicAPI");
const batchOpArrayParam_1 = require("../operation/batchOpArrayParam");
exports.DEWEB_INDEXER_CONTRACTS = {
    [utils_1.NetworkName.Mainnet]: 'AS12UpEfdonZxyFnsmrJfZbXLM3Gq6LaL3hPk7wTXqU4UZfnypKzF',
    [utils_1.NetworkName.Buildnet]: 'AS1TmA4GNpSYBseNNMXpbAp2trUwZxZy3T1sZ9Qd3Qdn9L8wGbMS',
};
/**
 * @class DewebIndexer
 * @extends SmartContract
 *
 * The DewebIndexer class provides methods to interact with the Deweb Indexer smart contract.
 * Deweb Indexer contract is available here: https://raw.githubusercontent.com/massalabs/DeWeb/refs/heads/main/deweb-index/assembly/contracts/deweb-index.ts
 *
 * @example
 * ```typescript
 * const dewebIndexer = await DewebIndexer.mainnet(provider);
 * const ownedDomains = await dewebIndexer.getIndexerWebsiteList("ownerAddress", provider);
 * ```
 *
 */
class DewebIndexer extends smartContracts_1.SmartContract {
    constructor(provider, chainId) {
        const address = chainId === utils_1.CHAIN_ID.Mainnet
            ? exports.DEWEB_INDEXER_CONTRACTS[utils_1.NetworkName.Mainnet]
            : exports.DEWEB_INDEXER_CONTRACTS[utils_1.NetworkName.Buildnet];
        super(provider, address);
    }
    static async fromProvider(provider) {
        const { chainId } = await provider.networkInfos();
        return new DewebIndexer(provider, chainId);
    }
    static mainnet(provider) {
        (0, utils_2.checkNetwork)(provider, true);
        return new DewebIndexer(provider, utils_1.CHAIN_ID.Mainnet);
    }
    static buildnet(provider) {
        (0, utils_2.checkNetwork)(provider, false);
        return new DewebIndexer(provider, utils_1.CHAIN_ID.Buildnet);
    }
    /**
     * Retrieves the list of deweb websites smart contract addresses belonging to the owner from the indexer contract
     * @param ownerAddress - The address of the owner
     * @param provider - The provider to use
     * @returns The list of deweb websites smart contract addresses belonging to the owner
     */
    async getIndexerWebsiteList(ownerAddress, provider) {
        const prefix = (0, indexer_keys_1.indexByOwnerBaseKey)(ownerAddress);
        // retrieves from indexer contract the list of websites addresses belonging to the owner
        let keys = [];
        try {
            keys = await provider.getStorageKeys(this.address, prefix); // retrieves addresses of websites
        }
        catch (error) {
            throw new Error('error retrieving indexer website list belonging to ' + ownerAddress, error);
        }
        // if the user doesn't have any websites registered on the indexer contract
        if (keys.length === 0) {
            return [];
        }
        /* check that returned addresses have files */
        const publicAPI = await publicAPI_1.PublicAPI.fromProvider(provider);
        // retrieve the addresses of the websites from corresponding keys retrieved from the indexer contract
        const websitesAddresses = keys.map((key) => key.slice(prefix.length));
        // batch the websites addresses in DEFAULT_MAX_ARGUMENT_ARRAY_SIZE sub array to prevent exceeding max argument limit
        const batchedWebsitesAddresses = (0, batchOpArrayParam_1.toBatch)(websitesAddresses, provider_1.DEFAULT_MAX_ARGUMENT_ARRAY_SIZE);
        let websitesFileLocationKeys = [];
        try {
            websitesFileLocationKeys = (await Promise.all(batchedWebsitesAddresses.map(async (websitesAddressesBatch) => {
                // retrieve files location keys for all websites addresses in the batch in a single request
                const result = await publicAPI.getAddressesDatastoreKeys(websitesAddressesBatch.map((address) => ({
                    address: (0, basicElements_1.bytesToStr)(address),
                    prefix: deweb_site_keys_1.FILE_LOCATION_TAG,
                    final: true,
                    maxCount: 1,
                })));
                return result;
            }))).flat(); // regroup all batch result into a single list
        }
        catch (error) {
            throw new Error("error while filtering websites that don't have files: " + error, error);
        }
        return websitesFileLocationKeys
            .filter((key) => key.keys.length > 0) // filter out websites that don't have files
            .map((key) => key.address); // get the addresses of the websites that have files
    }
}
exports.DewebIndexer = DewebIndexer;
