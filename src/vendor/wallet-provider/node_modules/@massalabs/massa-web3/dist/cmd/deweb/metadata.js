"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMultipleSitesGlobalMetadata = exports.extractWebsiteMetadata = void 0;
const provider_1 = require("../provider");
const publicAPI_1 = require("../client/publicAPI");
const deweb_site_keys_1 = require("./keys/deweb_site_keys");
const batchOpArrayParam_1 = require("../operation/batchOpArrayParam");
const const_1 = require("./const");
const serializers_1 = require("./serializers");
const serializers_2 = require("../basicElements/serializers");
const storage_1 = require("../client/storage");
/**
 * Extracts the metadata from a list of Metadata objects into a [[ParsedMetadata]] object
 * @param metadata - The list of Metadata objects of a deweb website
 * @returns A [[ParsedMetadata]] object
 */
function extractWebsiteMetadata(metadata) {
    return metadata.reduce((acc, m) => {
        if (m.key === const_1.LAST_UPDATE_KEY) {
            acc.lastUpdate = m.value;
        }
        else if (m.key === const_1.TITLE_METADATA_KEY) {
            acc.title = m.value;
        }
        else if (m.key === const_1.DESCRIPTION_METADATA_KEY) {
            acc.description = m.value;
        }
        else if (m.key.startsWith(const_1.KEYWORD_METADATA_KEY_PREFIX)) {
            if (!acc.keywords) {
                acc.keywords = [];
            }
            acc.keywords.push(m.value);
        }
        else {
            if (!acc.custom) {
                acc.custom = {};
            }
            acc.custom[m.key] = m.value;
        }
        return acc;
    }, {});
}
exports.extractWebsiteMetadata = extractWebsiteMetadata;
/**
 * Retrieves the global metadata for multiple addresses
 * @param addresses - The list of deweb smart contract addresses from which to retrieve global metadatas
 * @param provider - The provider to use
 * @param isFinal - Whether to get metadata from the final state or from the pending state. False by default.
 * @returns The global metadata for each address
 */
async function getMultipleSitesGlobalMetadata(addresses, provider, isFinal = false) {
    const publicAPI = await publicAPI_1.PublicAPI.fromProvider(provider);
    // get all global metadata keys for all addresses
    const addressesMetadataKeysList = await (0, storage_1.getMultipleAddressesDatastoreKeys)(publicAPI, addresses.map((address) => ({
        address,
        prefix: deweb_site_keys_1.GLOBAL_METADATA_TAG,
        final: isFinal,
    })));
    // regroup all keys from all addresses into a single list
    const metadataKeysList = addressesMetadataKeysList.reduce((acc, curr) => {
        acc.push(...curr.keys.map((key) => ({
            address: curr.address,
            key: key,
        })));
        return acc;
    }, []);
    // Use the batchListAndCall function to process metadata keys in batches
    const allMetadataEntries = await (0, batchOpArrayParam_1.batchListAndCall)(metadataKeysList, async (metadataKeysBatch) => {
        return publicAPI.getDatastoreEntries(metadataKeysBatch, isFinal);
    }, provider_1.DEFAULT_MAX_ARGUMENT_ARRAY_SIZE);
    const metadata = allMetadataEntries
        .map((metadataEntry, index) => {
        // map each metadata entry to a Metadata object
        const metadataKeyBytes = metadataKeysList[index].key.slice(deweb_site_keys_1.GLOBAL_METADATA_TAG.length);
        const key = (0, serializers_2.bytesToStr)(metadataKeyBytes);
        if (!metadataEntry) {
            return new serializers_1.Metadata(key);
        }
        const value = (0, serializers_2.bytesToStr)(metadataEntry);
        return new serializers_1.Metadata(key, value);
    })
        .reduce((acc, metadata, index) => {
        // group metadata by address
        if (index === 0) {
            acc.push([]);
            acc[0].push(metadata);
            return acc;
        }
        if (metadataKeysList[index].address === metadataKeysList[index - 1].address) {
            acc[acc.length - 1].push(metadata);
        }
        else {
            acc.push([]);
            acc[acc.length - 1].push(metadata);
        }
        return acc;
    }, [])
        .map((metadata) => extractWebsiteMetadata(metadata)); //convert metadata to ParsedMetadata
    return metadata;
}
exports.getMultipleSitesGlobalMetadata = getMultipleSitesGlobalMetadata;
