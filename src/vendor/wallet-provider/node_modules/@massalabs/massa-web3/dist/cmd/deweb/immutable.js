"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isImmutable = exports.areImmutables = exports.makeImmutable = void 0;
const operation_1 = require("../operation");
const __1 = require("..");
const networks_1 = require("../utils/networks");
/**
 * Makes a deweb smart contract immutable
 *
 * @remarks WARNING This operation is irreversible. Once made immutable, you will not be able to update this site anymore.
 * @param address - The deweb smart contract address
 * @param provider - The provider to use
 * @param waitFinal - Whether to wait for the final execution or the speculative execution. False by default.
 * @returns The operation
 * @example
 * ```typescript
 * const operation = await makeImmutable(address, provider)
 * await operation.waitFinalExecution()
 * ```
 */
async function makeImmutable(address, provider, waitFinal = false) {
    const operation = await provider.callSC({
        func: 'upgradeSC',
        target: address,
    });
    await (waitFinal
        ? operation.waitFinalExecution()
        : operation.waitSpeculativeExecution());
    return operation;
}
exports.makeImmutable = makeImmutable;
/**
 * indicates among a list of contract addresses if they are immutable
 * @remarks This function allows to check the immutable property of several contract addresses in a single call
 * @param contractAddresses - The list of deweb smart contract addresses
 * @param provider - The provider to use
 * @param isFinal - Whether to check if the contract is immutable in the final state or in the pending state. False by default.
 * @returns - List of boolean values indicating if the respective contract is immutable
 */
async function areImmutables(provider, contractAddresses, isFinal = false) {
    if (contractAddresses.length === 0) {
        return [];
    }
    const publicAPI = await __1.PublicAPI.fromProvider(provider);
    const bytecodes = await (0, operation_1.batchListAndCall)(contractAddresses, async (contractAddressesBatch) => {
        return publicAPI.executeMultipleGetAddressesBytecode(contractAddressesBatch.map((address) => ({
            address,
            is_final: isFinal, // eslint-disable-line @typescript-eslint/naming-convention
        })));
    }, __1.DEFAULT_MAX_ARGUMENT_ARRAY_SIZE);
    return bytecodes.map((bytecode) => bytecode.length === 0);
}
exports.areImmutables = areImmutables;
/**
 * Indicates if a given contract address is immutable
 * @param address - The deweb smart contract address
 * @param provider - The provider to use
 * @param isFinal - Whether to check if the contract is immutable in the final state or in the pending state. False by default.
 * @returns True if the contract is immutable, false otherwise
 */
async function isImmutable(address, provider, isFinal = false) {
    const networkInfo = await provider.networkInfos();
    let nodeUrl = networkInfo.url;
    if (!nodeUrl) {
        nodeUrl = (0, networks_1.getPublicApiByChainId)(networkInfo.chainId);
        if (!nodeUrl) {
            throw new Error(`Unknown network chainId: ${networkInfo.chainId}`);
        }
    }
    const client = new __1.PublicAPI(nodeUrl);
    const bytecode = await client.getAddressesBytecode({
        address: address,
        is_final: isFinal, // eslint-disable-line @typescript-eslint/naming-convention
    });
    return bytecode.length === 0;
}
exports.isImmutable = isImmutable;
