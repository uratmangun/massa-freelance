"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MRC20 = void 0;
const basicElements_1 = require("../basicElements");
const smartContracts_1 = require("../smartContracts");
const dataEntryNotFound_1 = require("../errors/dataEntryNotFound");
/**
 * @class MRC20
 *
 *
 * Class representing an MRC20 token smart contract.
 * Extends the SmartContract class to provide methods for interacting with an MRC20 token.
 * MRC20 contract is available here: https://github.com/massalabs/massa-standards/blob/main/smart-contracts/assembly/contracts/FT/token.ts
 *
 *  @example
 * ```typescript
 * const token = new MRC20(provider, <tokenAddr>);
 * const balance = await token.balanceOf(<accountAddr>);
 * console.log(`Your balance: ${balance}`);
 *
 * const transferOperation = await token.transfer(<recipientAddr>, BigInt(10000));
 * console.log(`Transfer operation id: ${transferOperation.id}`);
 * ```
 */
class MRC20 extends smartContracts_1.SmartContract {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _version;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _name;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _symbol;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    _decimals;
    async version(options) {
        if (this._version) {
            return this._version;
        }
        const res = await this.read('version', undefined, options);
        return (this._version = (0, basicElements_1.bytesToStr)(res.value));
    }
    async name() {
        if (this._name) {
            return this._name;
        }
        const res = await this.provider.readStorage(this.address, ['NAME'], true);
        if (!res[0]) {
            throw new dataEntryNotFound_1.ErrorDataEntryNotFound({ key: 'NAME', address: this.address });
        }
        return (this._name = (0, basicElements_1.bytesToStr)(res[0]));
    }
    async symbol() {
        if (this._symbol) {
            return this._symbol;
        }
        const res = await this.provider.readStorage(this.address, ['SYMBOL'], true);
        if (!res[0]) {
            throw new dataEntryNotFound_1.ErrorDataEntryNotFound({ key: 'SYMBOL', address: this.address });
        }
        return (this._symbol = (0, basicElements_1.bytesToStr)(res[0]));
    }
    async decimals() {
        if (this._decimals) {
            return this._decimals;
        }
        const res = await this.provider.readStorage(this.address, ['DECIMALS'], true);
        if (!res[0]) {
            throw new dataEntryNotFound_1.ErrorDataEntryNotFound({
                key: 'DECIMALS',
                address: this.address,
            });
        }
        return (this._decimals = Number(basicElements_1.U8.fromBytes(res[0])));
    }
    async totalSupply(final = true) {
        const res = await this.provider.readStorage(this.address, ['TOTAL_SUPPLY'], final);
        if (!res[0]) {
            throw new dataEntryNotFound_1.ErrorDataEntryNotFound({
                key: 'TOTAL_SUPPLY',
                address: this.address,
            });
        }
        return basicElements_1.U256.fromBytes(res[0]);
    }
    async balanceOf(address, options) {
        const res = await this.read('balanceOf', new basicElements_1.Args().addString(address), options);
        return basicElements_1.U256.fromBytes(res.value);
    }
    async balancesOf(addresses, final = true) {
        const res = await this.provider.readStorage(this.address, addresses.map((a) => `BALANCE${a}`), final);
        return res.map((v, i) => ({
            address: addresses[i],
            balance: v ? basicElements_1.U256.fromBytes(v) : 0n,
        }));
    }
    async transfer(to, amount, options) {
        let opts = options;
        if (!options?.coins) {
            const coins = await (0, basicElements_1.MRC20BalanceCreationCost)(this.provider, this.address, to);
            opts = {
                ...options,
                coins,
            };
        }
        return this.call('transfer', new basicElements_1.Args().addString(to).addU256(amount), opts);
    }
    async allowance(ownerAddress, spenderAddress, options) {
        const res = await this.read('allowance', new basicElements_1.Args().addString(ownerAddress).addString(spenderAddress), options);
        return basicElements_1.U256.fromBytes(res.value);
    }
    async increaseAllowance(spenderAddress, amount, options) {
        return this.call('increaseAllowance', new basicElements_1.Args().addString(spenderAddress).addU256(amount), options);
    }
    async decreaseAllowance(spenderAddress, amount, options) {
        return this.call('decreaseAllowance', new basicElements_1.Args().addString(spenderAddress).addU256(amount), options);
    }
    async transferFrom(spenderAddress, recipientAddress, amount, options) {
        let opts = options;
        if (!options?.coins) {
            const coins = await (0, basicElements_1.MRC20BalanceCreationCost)(this.provider, this.address, recipientAddress);
            opts = {
                ...options,
                coins,
            };
        }
        return this.call('transferFrom', new basicElements_1.Args()
            .addString(spenderAddress)
            .addString(recipientAddress)
            .addU256(amount), opts);
    }
}
exports.MRC20 = MRC20;
