"use strict";
/* eslint-disable @typescript-eslint/naming-convention */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcPublicProvider = void 0;
const utils_1 = require("../../utils");
const utils_2 = require("../../utils");
const basicElements_1 = require("../../basicElements");
const operation_1 = require("../../operation");
// Import from api
const public_pb_1 = require("../../generated/grpc/public_pb");
const operation_pb_1 = require("../../generated/grpc/massa/model/v1/operation_pb");
const slot_pb_1 = require("../../generated/grpc/massa/model/v1/slot_pb");
const endorsement_pb_1 = require("../../generated/grpc/massa/model/v1/endorsement_pb");
const address_pb_1 = require("../../generated/grpc/massa/model/v1/address_pb");
const block_pb_1 = require("../../generated/grpc/massa/model/v1/block_pb");
const datastore_pb_1 = require("../../generated/grpc/massa/model/v1/datastore_pb");
const execution_pb_1 = require("../../generated/grpc/massa/model/v1/execution_pb");
const amount_pb_1 = require("../../generated/grpc/massa/model/v1/amount_pb");
const PublicServiceClientPb_1 = require("../../generated/grpc/PublicServiceClientPb");
const wrappers_pb_1 = require("../../generated/grpc/google/protobuf/wrappers_pb");
const filterBuilder_1 = require("./filterBuilder");
const smartContracts_1 = require("../../smartContracts");
class GrpcPublicProvider {
    client;
    url;
    constructor(client, url) {
        this.client = client;
        this.url = url;
    }
    static fromGrpcUrl(url) {
        return new GrpcPublicProvider(new PublicServiceClientPb_1.PublicServiceClient(url), url);
    }
    /**
     * Streams new slot execution outputs
     * @param filters - The filters to apply to the stream
     * @returns A stream of new slot execution outputs
     */
    newSlotExecutionOutputsStream(filters) {
        const builder = new filterBuilder_1.FilterBuilder();
        // Status filter
        if (filters.status) {
            builder.addStatus(filters.status);
        }
        // Slot range filter
        if (filters.slotRange) {
            builder.addSlotRange(filters.slotRange);
        }
        // Async pool changes filters
        if (filters.asyncPoolChangesFilter) {
            builder.addAsyncPoolChangesFilter(filters.asyncPoolChangesFilter);
        }
        // Empty executed denounciation filter
        if (filters.emptyExecutedDenounciationFilter) {
            builder.addEmptyExecutedDenounciationFilter();
        }
        // Event filters
        if (filters.eventFilter) {
            builder.addEventFilter(filters.eventFilter);
        }
        // Executed ops changes filters
        if (filters.executedOpsChangesFilter) {
            builder.addExecutedOpsChangesFilter(filters.executedOpsChangesFilter);
        }
        // Ledger changes filters
        if (filters.ledgerChangesFilter) {
            builder.addLedgerChangesFilter(filters.ledgerChangesFilter);
        }
        const f = builder.build();
        const request = new public_pb_1.NewSlotExecutionOutputsServerRequest();
        request.setFiltersList(f);
        return this.client.newSlotExecutionOutputsServer(request);
    }
    /**
     * Streams new filled blocks
     * @param addresses - Optional list of addresses to filter by
     * @param blockIds - Optional list of block IDs to filter by
     * @param slotRange - Optional slot range to filter by
     * @returns A stream of new filled blocks
     */
    newFilledBlocksStream(addresses, blockIds, slotRange) {
        const request = new public_pb_1.NewFilledBlocksServerRequest();
        if (blockIds) {
            const filter = new public_pb_1.NewFilledBlocksFilter();
            filter.setBlockIds(new block_pb_1.BlockIds().setBlockIdsList(blockIds));
            request.addFilters(filter);
        }
        if (addresses) {
            const filter = new public_pb_1.NewFilledBlocksFilter();
            filter.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            request.addFilters(filter);
        }
        if (slotRange) {
            const filter = new public_pb_1.NewFilledBlocksFilter();
            filter.setSlotRange(slotRange);
            request.addFilters(filter);
        }
        return this.client.newFilledBlocksServer(request);
    }
    /**
     * Streams new endorsements
     * @param addresses - Optional list of addresses to filter by
     * @param endorsementIds - Optional list of endorsement IDs to filter by
     * @param blockIds - Optional list of block IDs to filter by
     * @returns A stream of new endorsements
     */
    newEndorsementsStream(addresses, endorsementIds, blockIds) {
        const request = new public_pb_1.NewEndorsementsServerRequest();
        if (endorsementIds) {
            const filter = new public_pb_1.NewEndorsementsFilter();
            filter.setEndorsementIds(new endorsement_pb_1.EndorsementIds().setEndorsementIdsList(endorsementIds));
            request.addFilters(filter);
        }
        if (addresses) {
            const filter = new public_pb_1.NewEndorsementsFilter();
            filter.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            request.addFilters(filter);
        }
        if (blockIds) {
            const filter = new public_pb_1.NewEndorsementsFilter();
            filter.setBlockIds(new block_pb_1.BlockIds().setBlockIdsList(blockIds));
            request.addFilters(filter);
        }
        return this.client.newEndorsementsServer(request);
    }
    /**
     * Streams new blocks
     * @param blockIds - Optional list of block IDs to filter by
     * @param addresses - Optional list of addresses to filter by
     * @param slotRange - Optional slot range to filter by
     * @returns A stream of new blocks
     */
    newBlockStream(addresses, blockIds, slotRange) {
        const request = new public_pb_1.NewBlocksServerRequest();
        if (blockIds) {
            const filter = new public_pb_1.NewBlocksFilter();
            filter.setBlockIds(new block_pb_1.BlockIds().setBlockIdsList(blockIds));
            request.addFilters(filter);
        }
        if (addresses) {
            const filter = new public_pb_1.NewBlocksFilter();
            filter.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            request.addFilters(filter);
        }
        if (slotRange) {
            const filter = new public_pb_1.NewBlocksFilter();
            filter.setSlotRange(slotRange);
            request.addFilters(filter);
        }
        return this.client.newBlocksServer(request);
    }
    /**
     * Streams new operations
     * @param addresses - Optional list of addresses to filter by
     * @param operationIds - Optional list of operation IDs to filter by
     * @param types - Optional list of operation types to filter by
     * @returns A stream of new operations
     */
    newOperationsStream(addresses, operationIds, types) {
        const request = new public_pb_1.NewOperationsServerRequest();
        if (operationIds) {
            const filter = new public_pb_1.NewOperationsFilter();
            filter.setOperationIds(new operation_pb_1.OperationIds().setOperationIdsList(operationIds));
            request.addFilters(filter);
        }
        if (addresses) {
            const filter = new public_pb_1.NewOperationsFilter();
            filter.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            request.addFilters(filter);
        }
        if (types) {
            const filter = new public_pb_1.NewOperationsFilter();
            const opTypes = new operation_pb_1.OpTypes();
            opTypes.setOpTypesList(types);
            filter.setOperationTypes(opTypes);
            request.addFilters(filter);
        }
        return this.client.newOperationsServer(request);
    }
    /**
     * Executes a state query on the blockchain
     */
    queryState(queries) {
        return this.client.queryState(new public_pb_1.QueryStateRequest().setQueriesList(queries));
    }
    async balanceOf(addresses, final = true) {
        const queries = addresses.map((address) => {
            const ret = new public_pb_1.ExecutionQueryRequestItem();
            if (final) {
                ret.setAddressBalanceFinal(new public_pb_1.AddressBalanceFinal().setAddress(address));
            }
            else {
                ret.setAddressBalanceCandidate(new public_pb_1.AddressBalanceCandidate().setAddress(address));
            }
            return ret;
        });
        const response = await this.client.queryState(new public_pb_1.QueryStateRequest().setQueriesList(queries));
        const balances = response
            .getResponsesList()
            .map((item, index) => {
            const responseItem = item;
            if (!responseItem) {
                console.warn(`Empty response received for address ${addresses[index]}`);
                return null;
            }
            if (responseItem.hasError()) {
                console.warn(`Error for address ${addresses[index]}: ${responseItem.getError()?.getMessage()}`);
                return null;
            }
            if (!responseItem.hasResult() ||
                !responseItem.getResult()?.hasAmount()) {
                console.warn(`Unexpected response format for address ${addresses[index]}`);
                return null;
            }
            return {
                address: addresses[index],
                balance: BigInt(responseItem.getResult()?.getAmount()?.getMantissa() ?? 0),
            };
        })
            .filter((item) => item !== null);
        return balances;
    }
    /**
     * Searches for operations based on IDs or addresses
     */
    async searchOperations(operationIds, addresses) {
        const queries = [];
        if (operationIds) {
            const o = new public_pb_1.SearchOperationsFilter();
            o.setOperationIds(new operation_pb_1.OperationIds().setOperationIdsList(operationIds));
            queries.push(o);
        }
        if (addresses) {
            const a = new public_pb_1.SearchOperationsFilter();
            a.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            queries.push(a);
        }
        return (await this.client.searchOperations(new public_pb_1.SearchOperationsRequest().setFiltersList(queries))).getOperationInfosList();
    }
    /**
     * Retrieves ABI call stacks for specified operations
     */
    async getOperationABICallStacks(operationIds) {
        return (await this.client.getOperationABICallStacks(new public_pb_1.GetOperationABICallStacksRequest().setOperationIdsList(operationIds))).getCallStacksList();
    }
    /**
     * Retrieves ABI call stacks for specified slots
     */
    async getSlotABICallStacks(slots) {
        const grpcSlots = slots.map((slot) => new slot_pb_1.Slot().setPeriod(slot.period).setThread(slot.thread));
        return (await this.client.getSlotABICallStacks(new public_pb_1.GetSlotABICallStacksRequest().setSlotsList(grpcSlots))).getSlotCallStacksList();
    }
    /**
     * Retrieves transfer information for specified slots
     */
    async getSlotTransfers(slots) {
        const grpcSlots = slots.map((slot) => new slot_pb_1.Slot().setPeriod(slot.period).setThread(slot.thread));
        return (await this.client.getSlotTransfers(new public_pb_1.GetSlotTransfersRequest().setSlotsList(grpcSlots))).getTransferEachSlotList();
    }
    /**
     * Searches for endorsements based on various criteria
     */
    async searchEndorsements(endorsementIds, addresses, blockIds) {
        const queries = [];
        if (endorsementIds) {
            const e = new public_pb_1.SearchEndorsementsFilter();
            e.setEndorsementIds(new endorsement_pb_1.EndorsementIds().setEndorsementIdsList(endorsementIds));
            queries.push(e);
        }
        if (addresses) {
            const a = new public_pb_1.SearchEndorsementsFilter();
            a.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            queries.push(a);
        }
        if (blockIds) {
            const b = new public_pb_1.SearchEndorsementsFilter();
            b.setBlockIds(new block_pb_1.BlockIds().setBlockIdsList(blockIds));
            queries.push(b);
        }
        return (await this.client.searchEndorsements(new public_pb_1.SearchEndorsementsRequest().setFiltersList(queries))).getEndorsementInfosList();
    }
    /**
     * Retrieves storage keys for a smart contract with optional filtering and pagination
     */
    async getStorageKeys(address, filter, final) {
        if (!address) {
            throw new Error('Address is required');
        }
        try {
            const queries = [];
            const prefix = filter
                ? typeof filter === 'string'
                    ? (0, basicElements_1.strToBytes)(filter)
                    : filter
                : new Uint8Array();
            const ret = new public_pb_1.ExecutionQueryRequestItem();
            if (final) {
                ret.setAddressDatastoreKeysFinal(new public_pb_1.AddressDatastoreKeysFinal().setAddress(address).setPrefix(prefix));
            }
            else {
                ret.setAddressDatastoreKeysCandidate(new public_pb_1.AddressDatastoreKeysCandidate()
                    .setAddress(address)
                    .setPrefix(prefix));
            }
            queries.push(ret);
            const response = await this.client.queryState(new public_pb_1.QueryStateRequest().setQueriesList(queries));
            if (response?.getResponsesList().length === 0) {
                throw new Error(`No response received for address ${address}`);
            }
            const addressInfo = response.getResponsesList()[0];
            if (addressInfo.hasError()) {
                throw new Error(`Query state error: ${addressInfo.getError()?.getMessage() || 'Unknown error'}`);
            }
            if (addressInfo.hasResult() && addressInfo.getResult()?.hasVecBytes()) {
                return (addressInfo
                    .getResult()
                    ?.getVecBytes()
                    ?.getItemsList()
                    .map((item) => typeof item === 'string' ? (0, basicElements_1.strToBytes)(item) : item) ?? []);
            }
            throw new Error(`Unexpected response type: ${addressInfo.getResponseCase()}, ` +
                `expected 'result' with 'vecBytes' but got '${addressInfo.hasResult() ? addressInfo.getResult() : 'N/A'}'`);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get storage keys: ${error.message}`);
            }
            throw new Error('Failed to get storage keys: Unknown error');
        }
    }
    /**
     * Reads storage values for specified keys in a smart contract
     */
    async readStorage(address, keys, final = true) {
        const filters = keys.map((item) => {
            const key = typeof item === 'string' ? (0, basicElements_1.strToBytes)(item) : item;
            const ret = new public_pb_1.GetDatastoreEntryFilter();
            ret.setAddressKey(new datastore_pb_1.AddressKeyEntry().setAddress(address).setKey(key));
            return ret;
        });
        const response = await this.client.getDatastoreEntries(new public_pb_1.GetDatastoreEntriesRequest().setFiltersList(filters));
        const datastoreEntries = response.getDatastoreEntriesList();
        return datastoreEntries.map((item) => {
            let value;
            if (final) {
                value = item.getFinalValue();
            }
            else {
                value = item.getCandidateValue();
            }
            if (typeof value === 'string') {
                return (0, basicElements_1.strToBytes)(value);
            }
            return value;
        });
    }
    /**
     * Retrieves the current transaction throughput of the network
     */
    async getTransactionsThroughput() {
        const request = new public_pb_1.GetTransactionsThroughputRequest();
        const response = await this.client.getTransactionsThroughput(request);
        return response.getThroughput();
    }
    /**
     * Retrieves selector draws for specified addresses and slot range
     */
    async getSelectorDraws(addresses, slotRange) {
        const queries = [];
        if (addresses) {
            const a = new public_pb_1.SelectorDrawsFilter();
            a.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            queries.push(a);
        }
        if (slotRange) {
            const s = new public_pb_1.SelectorDrawsFilter();
            s.setSlotRange(slotRange);
            queries.push(s);
        }
        const response = await this.client.getSelectorDraws(new public_pb_1.GetSelectorDrawsRequest().setFiltersList(queries));
        return response.getDrawsList();
    }
    /**
     * Retrieves detailed information about specified operations
     */
    async getOperations(operationIds) {
        const response = await this.client.getOperations(new public_pb_1.GetOperationsRequest().setOperationIdsList(operationIds));
        return response.getWrappedOperationsList();
    }
    /**
     * Retrieves the best parent blocks for the next block
     */
    async getNextBlockBestParent() {
        const response = await this.client.getNextBlockBestParents(new public_pb_1.GetNextBlockBestParentsRequest());
        return response.getBlockParentsList();
    }
    /**
     * Retrieves detailed information about specified endorsements
     */
    async getEndorsements(endorsementIds) {
        const response = await this.client.getEndorsements(new public_pb_1.GetEndorsementsRequest().setEndorsementIdsList(endorsementIds));
        return response.getWrappedEndorsementsList();
    }
    /**
     * Retrieves detailed information about specified blocks
     */
    async getBlocks(blockIds) {
        const response = await this.client.getBlocks(new public_pb_1.GetBlocksRequest().setBlockIdsList(blockIds));
        return response.getWrappedBlocksList();
    }
    /**
     * Searches for blocks based on various criteria
     */
    async searchBlocks(blockIds, addresses, slotRange) {
        const queries = [];
        if (blockIds) {
            const b = new public_pb_1.SearchBlocksFilter();
            b.setBlockIds(new block_pb_1.BlockIds().setBlockIdsList(blockIds));
            queries.push(b);
        }
        if (addresses) {
            const a = new public_pb_1.SearchBlocksFilter();
            a.setAddresses(new address_pb_1.Addresses().setAddressesList(addresses));
            queries.push(a);
        }
        if (slotRange) {
            const s = new public_pb_1.SearchBlocksFilter();
            s.setSlotRange(slotRange);
            queries.push(s);
        }
        return (await this.client.searchBlocks(new public_pb_1.SearchBlocksRequest().setFiltersList(queries))).getBlockInfosList();
    }
    /**
     * Retrieves events based on specified filters
     */
    async getEvents(filter) {
        const filters = [];
        if (filter.start !== undefined && filter.end !== undefined) {
            const ret = new public_pb_1.ScExecutionEventsFilter();
            ret.setSlotRange(new slot_pb_1.SlotRange()
                .setStartSlot(new slot_pb_1.Slot()
                .setPeriod(filter.start.period)
                .setThread(filter.start.thread))
                .setEndSlot(new slot_pb_1.Slot()
                .setPeriod(Number(filter.end.period))
                .setThread(filter.end.thread)));
            filters.push(ret);
        }
        else if (filter.callerAddress !== undefined) {
            const ret = new public_pb_1.ScExecutionEventsFilter();
            ret.setCallerAddress(filter.callerAddress);
            filters.push(ret);
        }
        else if (filter.smartContractAddress !== undefined) {
            const ret = new public_pb_1.ScExecutionEventsFilter();
            ret.setEmitterAddress(filter.smartContractAddress);
            filters.push(ret);
        }
        else if (filter.operationId !== undefined) {
            const ret = new public_pb_1.ScExecutionEventsFilter();
            ret.setOriginalOperationId(filter.operationId);
            filters.push(ret);
        }
        else if (filter.isError !== undefined) {
            const ret = new public_pb_1.ScExecutionEventsFilter();
            ret.setIsFailure(filter.isError);
            filters.push(ret);
        }
        const ret = new public_pb_1.ScExecutionEventsFilter();
        if (filter.isFinal !== undefined) {
            ret.setStatus(filter.isFinal
                ? execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_FINAL
                : execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_CANDIDATE);
        }
        else {
            ret.setStatus(execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_CANDIDATE);
        }
        filters.push(ret);
        const response = await this.client.getScExecutionEvents(new public_pb_1.GetScExecutionEventsRequest().setFiltersList(filters));
        const outputEvents = response
            .getEventsList()
            .filter((event) => event.getContext() !== null)
            .map((event) => {
            const context = {
                slot: {
                    period: Number(event.getContext()?.getOriginSlot()?.getPeriod() ?? 0),
                    thread: Number(event.getContext()?.getOriginSlot()?.getThread() ?? 0),
                },
                read_only: event.getContext()?.getStatus() ===
                    execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_READ_ONLY
                    ? true
                    : false,
                call_stack: event.getContext()?.getCallStackList() ?? [],
                index_in_slot: Number(event.getContext()?.getIndexInSlot() ?? 0),
                is_final: event.getContext()?.getStatus() ===
                    execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_FINAL
                    ? true
                    : false,
            };
            const outputEvent = {
                data: event.getData().toString(),
                context,
            };
            return outputEvent;
        });
        return outputEvents;
    }
    async networkInfos() {
        const status = await this.client.getStatus(new public_pb_1.GetStatusRequest());
        const chainId = BigInt(status.getStatus()?.getChainId() ?? 0);
        let networkName;
        if (chainId === utils_2.CHAIN_ID.Mainnet) {
            networkName = utils_1.NetworkName.Mainnet;
        }
        else if (chainId === utils_2.CHAIN_ID.Buildnet) {
            networkName = utils_1.NetworkName.Buildnet;
        }
        else {
            throw new Error(`Unknown chain id: ${chainId}`);
        }
        return {
            name: networkName,
            chainId,
            url: this.url,
            minimalFee: BigInt(status.getStatus()?.getMinimalFees()?.getMantissa() ?? 0),
        };
    }
    async getOperationStatus(opId) {
        const queries = [
            new public_pb_1.ExecutionQueryRequestItem().setOpExecutionStatusCandidate(new public_pb_1.OpExecutionStatusCandidate().setOperationId(opId)),
        ];
        const response = await this.client.queryState(new public_pb_1.QueryStateRequest().setQueriesList(queries));
        const list = response.getResponsesList();
        if (list.length === 0) {
            throw new Error('Operation not found');
        }
        const operation = list[0];
        if (operation.hasError()) {
            throw new Error('error in queryState');
        }
        if (operation.hasResult()) {
            switch (operation.getResult()?.getExecutionStatus()) {
                case public_pb_1.ExecutionQueryExecutionStatus.EXECUTION_QUERY_EXECUTION_STATUS_ALREADY_EXECUTED_WITH_FAILURE:
                    return operation_1.OperationStatus.Error;
                case public_pb_1.ExecutionQueryExecutionStatus.EXECUTION_QUERY_EXECUTION_STATUS_ALREADY_EXECUTED_WITH_SUCCESS:
                    return operation_1.OperationStatus.Success;
                case public_pb_1.ExecutionQueryExecutionStatus.EXECUTION_QUERY_EXECUTION_STATUS_EXECUTABLE_OR_EXPIRED:
                    return operation_1.OperationStatus.NotFound;
                case public_pb_1.ExecutionQueryExecutionStatus.EXECUTION_QUERY_EXECUTION_STATUS_UNSPECIFIED:
                    return operation_1.OperationStatus.NotFound;
            }
        }
        return operation_1.OperationStatus.NotFound;
    }
    /**
     * Retrieves a list of stakers with optional filtering by rolls
     */
    async getStakers(minRolls, maxRolls, limit) {
        const queries = [];
        if (minRolls) {
            const ret = new public_pb_1.StakersFilter();
            ret.setMinRolls(minRolls);
            queries.push(ret);
        }
        if (maxRolls) {
            const ret = new public_pb_1.StakersFilter();
            ret.setMaxRolls(maxRolls);
            queries.push(ret);
        }
        if (limit) {
            const ret = new public_pb_1.StakersFilter();
            ret.setLimit(limit);
            queries.push(ret);
        }
        const response = await this.client.getStakers(new public_pb_1.GetStakersRequest().setFiltersList(queries));
        return response.getStakersList();
    }
    async getNodeStatus() {
        const response = await this.client.getStatus(new public_pb_1.GetStatusRequest());
        const status = response.getStatus();
        if (!status) {
            throw new Error('Empty response received');
        }
        const nodeStatusInfo = {
            config: {
                blockReward: basicElements_1.Mas.toString(BigInt(status.getConfig()?.getBlockReward()?.getMantissa() ?? 0)),
                deltaF0: status.getConfig()?.getDeltaF0() ?? 0,
                genesisTimestamp: status.getConfig()?.getGenesisTimestamp()?.getMilliseconds() ?? 0,
                operationValidityPeriods: status.getConfig()?.getOperationValidityPeriods() ?? 0,
                periodsPerCycle: status.getConfig()?.getPeriodsPerCycle() ?? 0,
                rollPrice: basicElements_1.Mas.toString(BigInt(status.getConfig()?.getRollPrice()?.getMantissa() ?? 0)),
                t0: status.getConfig()?.getT0()?.getMilliseconds() ?? 0,
                threadCount: status.getConfig()?.getThreadCount() ?? 0,
            },
            currentCycle: status.getCurrentCycle(),
            currentTime: status.getCurrentTime()?.getMilliseconds() ?? 0,
            currentCycleTime: status.getCurrentCycleTime()?.getMilliseconds() ?? 0,
            nextCycleTime: status.getNextCycleTime()?.getMilliseconds() ?? 0,
            nodeId: status.getNodeId(),
            version: status.getVersion(),
            chainId: status.getChainId(),
            minimalFees: basicElements_1.Mas.toString(BigInt(status.getMinimalFees()?.getMantissa() ?? 0)),
            currentMipVersion: status.getCurrentMipVersion(),
        };
        return nodeStatusInfo;
    }
    async readSC(params) {
        const parameter = (0, utils_1.parseCallArgs)(params.parameter);
        const maxGas = params.maxGas ?? smartContracts_1.MAX_GAS_CALL;
        const request = new public_pb_1.ExecuteReadOnlyCallRequest();
        const call = new execution_pb_1.ReadOnlyExecutionCall();
        call.setMaxGas(Number(maxGas));
        if (params.caller) {
            const stringValue = new wrappers_pb_1.StringValue();
            stringValue.setValue(params.caller);
            call.setCallerAddress(stringValue);
        }
        call.setCallStackList([]);
        call.setFunctionCall(new execution_pb_1.FunctionCall()
            .setTargetAddress(params.target)
            .setTargetFunction(params.func)
            .setParameter(parameter));
        // fee
        if (params.fee) {
            call.setFee(new amount_pb_1.NativeAmount()
                .setMantissa(Number(params.fee))
                .setScale(basicElements_1.Mas.NB_DECIMALS));
        }
        else {
            // this should be removed when https://github.com/massalabs/massa/issues/4924 is fixed and released
            const { minimalFee } = await this.networkInfos();
            call.setFee(new amount_pb_1.NativeAmount()
                .setMantissa(Number(minimalFee))
                .setScale(basicElements_1.Mas.NB_DECIMALS));
        }
        request.setCall(call);
        const response = await this.client.executeReadOnlyCall(request);
        const output = response.getOutput();
        if (!output) {
            throw new Error('No output received');
        }
        const result = {
            value: output.getCallResult_asU8(),
            info: {
                gasCost: output.getUsedGas(),
                events: output
                    .getOut()
                    ?.getEventsList()
                    .map((ev) => {
                    const event = {
                        data: ev.getData_asB64(),
                        context: {
                            slot: {
                                period: Number(ev.getContext()?.getOriginSlot()?.getPeriod() ?? 0),
                                thread: Number(ev.getContext()?.getOriginSlot()?.getThread() ?? 0),
                            },
                            read_only: ev.getContext()?.getStatus() ===
                                execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_READ_ONLY,
                            call_stack: ev.getContext()?.getCallStackList() ?? [],
                            index_in_slot: Number(ev.getContext()?.getIndexInSlot() ?? 0),
                            is_final: ev.getContext()?.getStatus() ===
                                execution_pb_1.ScExecutionEventStatus.SC_EXECUTION_EVENT_STATUS_FINAL,
                        },
                    };
                    return event;
                }) ?? [],
            },
        };
        return result;
    }
    // eslint-disable-next-line class-methods-use-this
    executeSCReadOnly(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    params) {
        throw new Error('executeSCReadOnly not implemented for GrpcPublicProvider.');
    }
}
exports.GrpcPublicProvider = GrpcPublicProvider;
