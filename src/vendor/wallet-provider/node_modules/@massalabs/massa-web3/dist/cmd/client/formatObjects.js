"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeDatastore = exports.formatReadOnlyExecuteSCResponse = exports.formatReadOnlyExecuteSCParams = exports.formatReadOnlyCallResponse = exports.formatNodeStatusObject = void 0;
const tslib_1 = require("tslib");
const varint_1 = tslib_1.__importDefault(require("varint"));
const basicElements_1 = require("../basicElements");
const smartContracts_1 = require("../smartContracts");
function formatNodeStatusObject(status) {
    return {
        config: {
            blockReward: status.config.block_reward,
            deltaF0: status.config.delta_f0,
            endTimestamp: status.config.end_timestamp,
            genesisTimestamp: status.config.genesis_timestamp,
            maxBlockSize: status.config.max_block_size,
            operationValidityPeriods: status.config.operation_validity_periods,
            periodsPerCycle: status.config.periods_per_cycle,
            rollPrice: status.config.roll_price,
            t0: status.config.t0,
            threadCount: status.config.thread_count,
        },
        connectedNodes: status.connected_nodes,
        consensusStats: {
            cliqueCount: status.consensus_stats.clique_count,
            endTimespan: status.consensus_stats.end_timespan,
            finalBlockCount: status.consensus_stats.final_block_count,
            staleBlockCount: status.consensus_stats.stale_block_count,
            startTimespan: status.consensus_stats.start_timespan,
        },
        currentCycle: status.current_cycle,
        currentTime: status.current_time,
        currentCycleTime: status.current_cycle_time,
        nextCycleTime: status.next_cycle_time,
        lastSlot: status.last_slot,
        nextSlot: status.next_slot,
        networkStats: {
            activeNodeCount: status.network_stats.active_node_count,
            bannedPeerCount: status.network_stats.banned_peer_count,
            inConnectionCount: status.network_stats.in_connection_count,
            knownPeerCount: status.network_stats.known_peer_count,
            outConnectionCount: status.network_stats.out_connection_count,
        },
        nodeId: status.node_id,
        nodeIp: status.node_ip,
        poolStats: status.pool_stats,
        version: status.version,
        executionStats: {
            timeWindowStart: status.execution_stats.time_window_start,
            timeWindowEnd: status.execution_stats.time_window_end,
            finalBlockCount: status.execution_stats.final_block_count,
            finalExecutedOperationsCount: status.execution_stats.final_executed_operations_count,
            activeCursor: status.execution_stats.active_cursor,
            finalCursor: status.execution_stats.final_cursor,
        },
        chainId: status.chain_id,
        minimalFees: status.minimal_fees,
        currentMipVersion: status.current_mip_version,
    };
}
exports.formatNodeStatusObject = formatNodeStatusObject;
function formatReadOnlyCallResponse(res) {
    return {
        value: res.result.Ok ? new Uint8Array(res.result.Ok) : new Uint8Array(),
        info: {
            gasCost: res.gas_cost,
            error: res.result.Error,
            events: res.output_events,
            stateChanges: {
                ledgerChanges: res.state_changes.ledger_changes,
                asyncPoolChanges: res.state_changes.async_pool_changes,
                posChanges: res.state_changes.pos_changes,
                executedOpsChanges: res.state_changes.executed_ops_changes,
                executedDenunciationsChanges: res.state_changes.executed_denunciations_changes,
                executionTrailHashChange: res.state_changes.execution_trail_hash_change,
            },
        },
    };
}
exports.formatReadOnlyCallResponse = formatReadOnlyCallResponse;
function formatReadOnlyExecuteSCParams(params) {
    const res = {
        max_gas: Number(params.maxGas ?? smartContracts_1.MAX_GAS_EXECUTE),
        bytecode: Array.from(params.byteCode),
        address: params.caller,
        // Datastore is serialized manually as a workaround of https://github.com/massalabs/massa/issues/4775
        operation_datastore: params.datastore
            ? serializeDatastore(params.datastore)
            : null,
        fee: params.fee ? basicElements_1.Mas.toString(params.fee) : null,
    };
    return res;
}
exports.formatReadOnlyExecuteSCParams = formatReadOnlyExecuteSCParams;
function formatReadOnlyExecuteSCResponse(res) {
    return {
        value: res.result.Ok ? new Uint8Array(res.result.Ok) : new Uint8Array(),
        gasCost: res.gas_cost,
        error: res.result.Error,
        events: res.output_events,
        stateChanges: {
            ledgerChanges: res.state_changes.ledger_changes,
            asyncPoolChanges: res.state_changes.async_pool_changes,
            posChanges: res.state_changes.pos_changes,
            executedOpsChanges: res.state_changes.executed_ops_changes,
            executedDenunciationsChanges: res.state_changes.executed_denunciations_changes,
            executionTrailHashChange: res.state_changes.execution_trail_hash_change,
        },
        executedAt: res.executed_at,
    };
}
exports.formatReadOnlyExecuteSCResponse = formatReadOnlyExecuteSCResponse;
function serializeDatastore(data) {
    // Serialize the entry count as a U64VarInt
    const entryCount = data.size;
    const buffer = [...varint_1.default.encode(entryCount)];
    // Serialize each key-value pair
    for (const [key, value] of data.entries()) {
        buffer.push(...varint_1.default.encode(key.length));
        buffer.push(...key);
        buffer.push(...varint_1.default.encode(value.length));
        buffer.push(...value);
    }
    return buffer;
}
exports.serializeDatastore = serializeDatastore;
